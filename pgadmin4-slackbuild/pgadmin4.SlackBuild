#!/bin/bash

# Updated for pgAdmin4 version 6.1
# Date: October 22/2021

# Slackware build script for pgadmin4
# Copyright 2019 Jeremy Hansen jebrhansen+SBo -at- gmail.com
# All rights reserved.
#
# Redistribution and use of this script, with or without modification, is
# permitted provided that the following conditions are met:
#
# 1. Redistributions of this script must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
#  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
#  EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
#  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
#  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
#  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Modified by: Wael Hammoudeh - w_hammoudeh at hotmail.com

CWD=$(pwd)
PRGNAME=pgadmin4
VERSION="6.1"
BUILD=${BUILD:-1}
TAG=${TAG:-_wh}

OUTPUT=${OUTPUT:-/tmp}
TMP=${TMP:-/tmp/WH}

# call uname() to set ARCH
if [ -z "$ARCH" ]; then
  case "$( uname -m )" in
    i?86) ARCH=i586 ;;
    arm*) ARCH=arm ;;
       *) ARCH=$( uname -m ) ;;
  esac
fi

LIBDIRSUFFIX=""
if [ "$ARCH" = "x86_64" ]; then
  LIBDIRSUFFIX="64"
fi

# we use two source files; do we have both?
NW_VER="0.55.0"
NW_NAME=nwjs-v${NW_VER}-linux-x64
NW_DIR=${CWD}/${NW_NAME}

SOURCEDIR=${CWD}/${PRGNAME}-${VERSION}

if [ ! -f $CWD/${PRGNAME}-${VERSION}.tar.gz ]; then
    echo "Missing source for $PRGNAME. Exiting"
    exit 1
fi

if [ ! -f $CWD/$NW_NAME.tar.gz ]; then
    echo "Missing source for nwJS tar ball. Exiting"
    exit 1
fi

# we need postgresql bin directory in our path
PG_PATH=`/usr/bin/pg_config --bindir`

if [ -z "$PG_PATH" ]; then
    echo "Could not get postgresql binary directory from pg_config."
    echo "Is postgresql package installed? Exiting."
    exit 1
fi

export PATH=$PG_PATH:$PATH

# exit on error
set -e

# Debugging shizz
trap 'ERRCODE=$? && if [ ${ERRCODE} -ne 0 ]; then echo "The command \"${BASH_COMMAND}\" failed in \"${FUNCNAME}\" with exit code ${ERRCODE}."; fi' EXIT

# make skelton directories for our package -- also /usr/doc/$PRGNAME-$VERSION
BUILDROOT=${TMP}/${PRGNAME}
PKGROOT=${BUILDROOT}/opt/${PRGNAME}
PKGBIN=${PKGROOT}/bin
PKGVENV=${PKGROOT}/venv
PKGWEB=${PKGROOT}/web
PKGDOCS=${PKGROOT}/docs
SYS_SHARE=${BUILDROOT}/usr/share

# start with empty directories
rm -rf ${SOURCEDIR} ${BUILDROOT} ${NW_DIR}

mkdir -p $TMP $OUTPUT $BUILDROOT $PKGROOT $PKGBIN $PKGVENV $PKGWEB $PKGDOCS $SYS_SHARE

tar xvzf $CWD/$PRGNAME-$VERSION.tar.gz

cd $SOURCEDIR

# set sane permissions
chown -R root:root .
find -L . \
 \( -perm 777 -o -perm 775 -o -perm 750 -o -perm 711 -o -perm 555 \
  -o -perm 511 \) -exec chmod 755 {} \; -o \
 \( -perm 666 -o -perm 664 -o -perm 640 -o -perm 600 -o -perm 444 \
  -o -perm 440 -o -perm 400 \) -exec chmod 644 {} \;

# see $SOURCEDIR/pkg/linux/build-functions.sh file

echo "Creating the virtual environment..."

cd ${PKGROOT}

# Create the blank venv -- in our PKGVENV directory
python3 -m venv ${PKGVENV}
source ${PKGVENV}/bin/activate

# Make sure we have the wheel package present, as well as the latest pip
pip3 install --upgrade pip
pip3 install wheel

# Sphinx module is not included in Slackware, add to requirements.txt file;
# needed to build docs
echo Sphinx >> ${SOURCEDIR}/requirements.txt

# Install the requirements for venv
pip3 install --no-cache-dir --no-binary psycopg2 -r ${SOURCEDIR}/requirements.txt
#pip3 install --no-binary psycopg2 -r ${SOURCEDIR}/requirements.txt

VENVPATH="/opt/${PRGNAME}/venv"

# Fixup the paths in the venv activation scripts -- note double quets
sed -i "s|VIRTUAL_ENV=.*|VIRTUAL_ENV=\"${VENVPATH}\"|g" venv/bin/activate
sed -i "s|setenv VIRTUAL_ENV .*|setenv VIRTUAL_ENV \"${VENVPATH}\"|g" venv/bin/activate.csh
sed -i "s|set -gx VIRTUAL_ENV .*|set -gx VIRTUAL_ENV \"${VENVPATH}\"|g" venv/bin/activate.fish

rm -rf ${PKGVENV}/bin/__pycache__

# Fixup hash bangs
sed -i 's/#!.*\/python3/#\!\/opt\/pgadmin4\/venv\/bin\/python3/g' venv/bin/*

# Figure out some paths for use when completing the venv
# Use "python3" here as we want the venv path
PYMODULES_PATH=$(python3 -c "from distutils.sysconfig import get_python_lib; print(get_python_lib())")
DIR_PYMODULES_PATH=`dirname ${PYMODULES_PATH}`

# Use /usr/bin/python3 here as we want the system path
PYSYSLIB_PATH=$(/usr/bin/python3 -c "import sys; print('%s/lib64/python%d.%.d' % (sys.prefix, sys.version_info.major, sys.version_info.minor))")

# Symlink in the rest of the Python libs. This is required because the runtime
# will clear PYTHONHOME for safety, which has the side-effect of preventing
# it from finding modules that are not explicitly included in the venv
cd ${DIR_PYMODULES_PATH}

# Files
for FULLPATH in ${PYSYSLIB_PATH}/*.py; do
    FILE=${FULLPATH##*/}
    if [ ! -e ${FILE} ]; then
        ln -s ${FULLPATH} ${FILE}
    fi
done

# Paths
for FULLPATH in ${PYSYSLIB_PATH}/*/; do
    FULLPATH=${FULLPATH%*/}
    FILE=${FULLPATH##*/}
    if [ ! -e ${FILE} ]; then
        ln -s ${FULLPATH} ${FILE}
    fi
done

# Remove tests
cd site-packages
find . -name "test" -type d -print0 | xargs -0 rm -rf
find . -name "tests" -type d -print0 | xargs -0 rm -rf

# Link the python<version> directory to python so that the private environment path is found by the application.
if test -d ${DIR_PYMODULES_PATH}; then
    ln -s $(basename ${DIR_PYMODULES_PATH}) ${DIR_PYMODULES_PATH}/../python
fi

# build runtime
cd $CWD

tar zxvf ${CWD}/${NW_NAME}.tar.gz

# set sane permissions
chown -R root:root ${NW_DIR}
find -L ${NW_DIR} \
 \( -perm 777 -o -perm 775 -o -perm 750 -o -perm 711 -o -perm 555 \
  -o -perm 511 \) -exec chmod 755 {} \; -o \
 \( -perm 666 -o -perm 664 -o -perm 640 -o -perm 600 -o -perm 444 \
  -o -perm 440 -o -perm 400 \) -exec chmod 644 {} \;

# Copy nwjs into PKGBIN directory
cp -r ${NW_DIR}/* ${PKGBIN}/

# rename nw to pgadmin4
mv ${PKGBIN}/nw ${PKGBIN}/${PRGNAME}

# copy from ${SOURCEDIR}/runtime the assets & src directories plus package.json file to PKGBIN
cp -rp ${SOURCEDIR}/runtime/assets ${PKGBIN}
cp -rp ${SOURCEDIR}/runtime/src ${PKGBIN}
cp ${SOURCEDIR}/runtime/package.json ${PKGBIN}/.

yarn --cwd ${PKGBIN} install --production=true

# pgadmin4 desktop needs files and executables from $SOURCEDIR/web directory
cp -r ${SOURCEDIR}/web/ ${PKGROOT}

cd ${PKGWEB}

yarn install
yarn run bundle

# remove not needed
rm -f pgadmin4.db config_local.*
rm -rf karma.conf.js package.json node_modules/ regression/ tools/ pgadmin/static/js/generated/.cache
find . -name "tests" -type d -print0 | xargs -0 rm -rf
find . -name "feature_tests" -type d -print0 | xargs -0 rm -rf
find . -name "__pycache__" -type d -print0 | xargs -0 rm -rf

# use just built PVE to build docs
echo "Building the documentation..."

mkdir -p ${PKGDOCS}/en_US/html
cd "${SOURCEDIR}/docs/en_US"

python3 build_code_snippet.py
python3 ${PKGVENV}/bin/sphinx-build . "${PKGDOCS}/en_US/html"

# Ensure our venv will use the correct Python interpretor, even if the
# user has configured an alternative default.
# DO THIS LAST!
cd "${PKGVENV}/bin"
PYTHON_INTERPRETER=$(/usr/bin/python3 -c "import os, sys; print(os.path.realpath(sys.executable))")
rm python && ln -s python3 python
rm python3 && ln -s "${PYTHON_INTERPRETER}" python3
# TODO :: is the above correct? I think ......????

# needed config files
install -Dm 644 /dev/stdin "$PKGWEB/config_distro.py" <<END
SERVER_MODE = False
HELP_PATH = "/opt/pgadmin4/docs/en_US/html"
END
cp $PKGWEB/config_distro.py $PKGWEB/config_local.py

# Web setup script -- you are on your own for this
mkdir -p ${PKGWEB}/usr/bin/
cp ${SOURCEDIR}/pkg/linux/setup-web.sh ${PKGWEB}/usr/bin/

# Install icons
install -Dm 644 ${SOURCEDIR}/pkg/linux/${PRGNAME}-16x16.png \
                "$SYS_SHARE/icons/hicolor/16x16/apps/${PRGNAME}.png"
install -Dm 644 ${SOURCEDIR}/pkg/linux/${PRGNAME}-32x32.png \
                "$SYS_SHARE/icons/hicolor/32x32/apps/${PRGNAME}.png"
install -Dm 644 ${SOURCEDIR}/pkg/linux/${PRGNAME}-48x48.png \
                "$SYS_SHARE/icons/hicolor/48x48/apps/${PRGNAME}.png"
install -Dm 644 ${SOURCEDIR}/pkg/linux/${PRGNAME}-64x64.png \
                "$SYS_SHARE/icons/hicolor/64x64/apps/${PRGNAME}.png"
install -Dm 644 ${SOURCEDIR}/pkg/linux/${PRGNAME}-128x128.png \
                "$SYS_SHARE/icons/hicolor/128x128/apps/${PRGNAME}.png"

# fix path in desktop file
sed -i 's/Exec=\/usr\/pgadmin4\/bin\/pgadmin4/Exec=\/opt\/pgadmin4\/bin\/pgadmin4/' \
           ${SOURCEDIR}/pkg/linux/pgadmin4.desktop
install -Dm 644 "${SOURCEDIR}/pkg/linux/pgadmin4.desktop" \
                "${SYS_SHARE}/applications/pgadmin4.desktop"

# License files
cp "${SOURCEDIR}/LICENSE" "${PKGROOT}/"
cp "${SOURCEDIR}/DEPENDENCIES" "${PKGROOT}/"
cp "${SOURCEDIR}/README.md" "${PKGROOT}/"

# save our build scripts
MYDOC=$BUILDROOT/usr/doc/$PRGNAME-$VERSION
mkdir -p $MYDOC
cp $CWD/LICENSE $MYDOC/
cp $CWD/README $MYDOC/
cp $CWD/$PRGNAME.SlackBuild $MYDOC/
cp $CWD/$PRGNAME.info $MYDOC/
cp $CWD/slack-desc $MYDOC/

mkdir -p $BUILDROOT/install
cat $CWD/slack-desc > $BUILDROOT/install/slack-desc

cd $BUILDROOT
/sbin/makepkg -l y -c n $OUTPUT/$PRGNAME-$VERSION-$ARCH-$BUILD$TAG.txz

exit 0
